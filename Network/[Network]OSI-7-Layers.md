# OSI 7 계층

##  OSI 7계층이란?
OSI란 Open System Interconnection의 약어로 국제 표준화 기구 ISO가 제안한 네트워크 통신의 표준안이다.
7계층으로 나눈 이유는 네트워크 통신 도중 발생할 수 있는 문제들을 각각의 레벨 안에서 처리하기 위해서이다.

<br>

![osi-7-layers](osi-7-layers.png)

---

## 1계층 - 물리 계층 (Physical Layer)

> * 장비: 리피터, 케이블, 허브  
> * 데이터 단위 : 비트 (bit)

물리계층에서는 말그대로 통신의 물리적인 것을 담당한다.
유선 LAN 기술을 표준화한 **IEEE802.3**과 무선 LAN 기술을 표준화 한 **IEEE802.11**로 나눌 수 있다.
IEEE802.3의 프로토콜 이름은 `[전송속도] BASE - [전송 매체나 레이저의 종류]` 의 형태로 지어진다.  
ex) 10GBASE-T (LAN 케이블[트위스트 페어 케이블]로 10Gbps의 전송 속도를 구현하는 프로토콜)  

**전송 속도**

| 표기   | 전송 속도     |
|------|-----------|
| 100  | 100Mbps   |
| 1000 | 1Gbps     |
| 10G  | 10Gbps    |
| 25G  | 25Gbps    |
| 40G  | 40Gbps    |
| 100G | 100Gbps   |

**전송 매체나 레이저의 종류**

| 표기  | 의미          |
|-----|-------------|
| T   | 트위트스 페어 케이블 |
| S   | 단파장 레이저     |
| L   | 장파장 레이저     |
| C   | 동축 케이블      |

### 트위스트 페어 케이블 
트위스트 페어 케이블은 컽으로 보기에는 하나의 케이블이지만, 사실 8가닥의 구리선을 두가닥씩 짝지어(pair) 꼬아서(twisted) 하나로 묶은 케이블이다.
실드 유무에 따라 **UTP**(Unshielded Twisted Pair)와 **STP**(Shielded Twisted Pair) 케이블로 분류할 수 있다.  
서로 꼬아져 있는 이유는 다른 전자기적 간섭을 최소화하기 위해서이다.

### 광섬유 케이블
광섬유 케이블은 거리를 늘려도 신호가 쉽게 감쇠하지 않기에 광대역을 유지할 수 있다. 
빛의 굴절률이 높은 **코어**(core)와, 굴절률이 비교적 낮은 **클래딩**(cladding)의 2층으로 구성되어 있고, 이 빛의 전송로를 모드(mode)라고 부른다.  
모드가 여럿 있다면 *다중 모드 광섬유 케이블*(MMF)이고 코어 지름이 작고 클래딩 비중이 커서 코어를 흐르는 모드가 하나라면 *단일 모드 광섬유 케이블*(SMF)이다.  

| 비교 항목      | 트위스트 페어 케이블 | 광섬유 케이블 |
|------------|-------------|---------|
| 전송 매체 재료   | 구리          | 유리      |
| 전송 속도      | 느림          | 빠름      |
| 신호 감쇄      | 큼           | 적음      |
| 전송 거리      | 짧음          | 김       |
| 전자석 노이즈 경향 | 큼           | 없음      | 
| 반환         | 쉬움          | 어려움     | <!-무엇을 반환하는거지?>
| 비용         | 적음          | 많음      |


<br>

---

## 2계층 - 데이터링크 계층 (Datalink Layer)

> * 장비: 브릿지, 스위치  
> * 데이터 단위 : 프레임 (frame)

데이터링크 계층은 같은 네트워크에 있는 단말을 식별하고, 물리 계층 위에서 비트열을 정확히 전송하는 구조를 제공한다.  
에러검출, 재전송, 흐름 제어의 역활을 수행한다.
데이터링크 계층에서 통신하려면 수신지와 송신지의 **MAC**주소가 필요하다.  

### MAC 주소
MAC 주소는 이더넷 네트워크에 접속되어 있는 단말의 식별 ID이다. 6바이트(48bit)로 구성되며, 16진수로 표기한다.  
`00-0c-29-43-5e-be` 혹은 `04:0c:ce:da:3a:6c`  
MAC 주소의 상위 3바이트는 IEEE가 벤더별로 할당한 벤더 코드로 
**OUI**(Organizationally Unique Identifier)라 
부르고, 통신하는 단말의 NIC를 어떤 벤더가 제조했는지 [사이트](http://standards-oui.ieee.org/oui/oui.txt)에서 확인할 수 있다.  
하위 3바이트는 **UAA**(Universal Administered Address)라 부르고 출하 시 벤더에서 할당하거나 무작위로 생성한 값이다.  

### 통신
이더넷 네트워크에서 통신은 3가지로 구분된다.

#### 유니캐스트(unicast)
유니캐스트는 1대 1통신이다. 때문에 서로의 MAC주소를 갖고 송신지 MAC주소, 수신지 MAC주소를 만든다. 웹이나 메일 등 인터넷 통신의 대부분은 유니캐스트이다.  
<br>

#### 브로드캐스트(broadcast)
브로드캐스트는 1대 n통신이다. 여기에서의 n은 같은 이더넷 네트워크에 접속되어 있는 자신 외의 모든 단말을 의미한다. 
A단말이 브로드캐스트 송신을 하면 그 이더넷 네트워크에 있는 A이외의 모든 단말이 그 프레임을 수신한다. 이때 송신지 MAC주소는 A단말의 MAC주소이고, 
수신지 MAC주소는 어느 하나 특정할 수 없기 때문에 6바이트가 모두 1인 값, 즉 `ff:ff:ff:ff:ff:ff`를 사용한다.  

<br>

#### 멀티캐스트(multicast)
멀티캐스트는 1대 n통신이다. 여기에서의 n은 특정 그룹에 속하는 단말이다. A단말이 멀티캐스트 송신을 하면 그 그룹에 있는 단말들만 그 패킷을 수신한다.  
~~트위터의 써클이나 인스타그램의 친한 친구와 같은 기능이라고 할 수 있다. 트위터 써클은 최근에 결함이 있는것 같지만~~  
송신지의 MAC 주소는 송신 단말의 MAC 주소가 그대로 사용되고, 수신지 MAC 주소는 네트워크 계층에서 받아온 IP를 이용한다.

### L2 스위치
L2 스위치는 이더넷 헤더에 포함된 송신지 MAC 주소와 자신의 포트 번호를 MAC 주소 테이블이라는 메모리상의 테이블로 관리하면서,
이더넷프레임의 전송 대상지를 바꾸어 통신 효율을 높인다.

<br>

---

## 3계층 - 네트워크 계층 (Network Layer)

> * 프로토콜 : 라우터, IP
> * 데이터 단위: 패킷 (packet)  


네트워크 계층에서는 라우터를 사용하여 경로 설정(라우팅) 역활을 한다.  
**IP**주소를 사용하고, 데이터 단위는 패킷이다.  

### IP
IP는 Internet Protocol의 약어로 통신에 사용하는 주소이다.  
IP에는 IPv4와 IPv6라는 두가지 버전이 존재한다.  


#### IPv4
ex) `192.168.1.1`, `128.0.0.1`  

IPv4는 4바이트(32비트)로 구성되어 있으며 8비트씩 점(.) 으로 구분하여 10진수로 표기한다. 그리고 다섯개의 클래스와 서브넷 마스킹을 사용한다.  
헤더의 길이는 20바이트(160비트)이며, 다음은 헤더 필드의 포함된 정보들이다.  

- 버전 (4비트)  
버전필드에는 IPv4의 버전인 0100(2) 가 들어가게 된다.  

* 헤더 길이 (4비트)  
IPv4의 헤더 길이를 나타내는 필드이고, Internet Header Length의 약자로 `IHL`이라고 부르기도 한다.  


* ToS (8비트)  
ToS는 `Type of Service`의 약어로, 전송되어 오는 IPv4 패킷의 우선도를 확인할 수 있다. 우선 제어나 대역 제어,
혼잡 제어 등 `QoS`(Quality of Service)에서 사용한다.  

 
* 패킷 길이 (16비트)  
패킷 길이는 IPv4 헤더와 IPv4 페이로드를 합친 패킷 전체의 길이를 나타내는 필드이다. 
여기서 페이로드란 실제 전하고자 하는 데이터가 담긴 부분을 말한다.  


* 식별자 (16비트)  
패킷 교환 방식 통신에서는 데이터를 패킷 단위로 쪼개서 보내는데, 이 처리를 **IP 프래그멘테이션**(IP fragmentation)이라고 부른다.  
이 IP 프래그멘테이션에 관한 정보를 식별자와 플래그 그리고 프래그먼트 오프 셋이 담고 있다.
쪼갯 데이터를 나중에 다시 합치기 위한 식별자가 담겨있다.  
  

* 플래그 (3비트)  
1번째 비트: 사용하지 않음  
2번째 비트: **DF**(Don't Fragment) 0이면 프래그멘테이션 허가, 1이면 불허  
3번째 비트: **MF**(More Fragment) 0이면 프래그멘테이션된 패킷이 계속되지 않음, 1이면 패킷에 계속됨   



* 프래그먼트 오프셋 (13비트)  
프래그멘테이션 한 뒤 그 패킷이 오리지널 패킷의 앞쪽부터 어느 위치에 있는지를 나타내는 필드이다.  
시작 인덱스는 0이다.  


* TTL (8비트)  
**TTL**(Time To Live)은 패킷의 수명을 나타내는 필드이다. IP에서의 패킷 수명은 `경유하는 라우터의 수`를 의미한다.  
경우하는 라우터의 수를 홉(hop) 수라고 부른다. 네트워크를 경유할 때 1씩 줄어들고, TTL 값이 0이 되면 그 페킷은 파기되고, 
패킷을 파기한 라우터는 **Time-to-live exceed**라는 메시지를 `ICMP`에 반환하고, 패킷을 파기한 것을 송신지 단말에 전달한다.  


* 프로토콜 번호 (8비트)  
IPv4 페이로드가 어떤 프로토콜로 구성되어 있는지를 나타내는 필드이다.

| 프로토콜 | 번호                                                |
|------|---------------------------------------------------|
| 1    | ICMP(Internet Control Message Protocol)           |
| 2    | IGMP(Internet Group Management Protocol)          |
| 6    | TCP(Transmission Control Protocol)                |
| 17   | UDP(User Datagram Protocol)                       |
| 47   | GRE(Generic Routing Encapsulation)                |
| 50   | ESP(Encapsulating Security Payload)               |
| 88   | EIGRP(Enhanced Interior Gateway Routing Protocol) |
| 89   | OSPF(Open Shortest Path First)                    |
| 112  | VRRP(Virtual Roughter Redundancy Protocol)        |

* 헤더 체크섬 (16비트)  
IPv4의 정합성을 체크하기 위한 필드로 1의 보수 연산을 사용한다.  

* 송수신지 IPv4 주소(각각 32비트)
여기까지가 이제 IPv4의 헤더 정보이고, 송신지, 수신지의 IPv4의 주소가 담긴다.  

### 서브넷 마스크 (subnet mask)
IPv4 주소는 **네트워크 부분**과 **호스트 부분** 2개로 나눠져 있다. 네트워크 부분은 속한 네트워크를 나타내고
호스트 부분은 그 속한 네트워크 중에서 자신의 단말을 나타낸다. 서브넷 마스크는 이 2개를 구분해주며, 네트워크 부분은 1로, 
호스트 부분은 0으로 표현한다.  

IPv4 주소  
192.168.100.1  

서브넷 마스크  
255.255.255.0  

서브넷 마스크가 다음과 같이 있으면 총 24비트가 1로 채워진 것이다. 그러면 IP주소에서 192.168.100 까지가 네트워크 부분인 것이고,
나머지 1 이 호스트 부분인 것이다.  


| 주소 클래스 | 용도         | 시작 비트 | 시작 IP 주소  | 종료 IP 주소        | 네트워크 부분 | 호스트 부분 |
|--------|------------|-------|-----------|-----------------|---------|--------|
| 클래스 A  | 유니캐스트(대규모) | 0     | 0.0.0.0   | 127.255.255.255 | 8비트     | 24비트   |
| 클래스 B  | 유니캐스트(중규모) | 10    | 128.0.0.0 | 191.255.255.255 | 16비트    | 16비트   |
| 클래스 C  | 유니캐스트(소규모) | 110   | 192.0.0.0 | 223.255.255.255 | 24비트    | 8비트    |
| 클래스 D  | 멀티캐스트      | 1110  | 224.0.0.0 | 239.255.255.255 | -       | -      |
| 클래스 E  | 연구, 예약용    | 1111  | 240.0.0.0 | 255.255.255.255 | -       | -      |

#### IPv6
ex) `2001:0bd8:1234:90ab:cdef:1234:5678`  
IPv4가 32비트로 최대 약 43억 개(2^32)의  IP주소를 표현할 수 있었는데, 80억 명의 전 세계 인구가 하나의 IP도 사용하지 못할 만큼
부족하다. 그리고 최근에는 PC나 서버뿐만 아니라 가전 제품, 센서 등에도 IP 주소가 필요해졌기에 새로운 대책이 필요했는데, 그것이 바로 IPv6이다.  
IPv6는 128비트를 16비트씩 ':'(콜론) 을 이용해 8개로 구분해 16진수로 표기한다.  
IPv6의 헤더를 살펴보면 IPv4보다 훨씬 더 간단해졌다.  

헤더 길이는 40바이트(320비트)로 고정되어 있기 때문에 패킷 헤더의 길이를 조사할 필요가 없어졌다. 
때문에 성능도 향상되었다.  

* 버전 (4비트)  
IP 버전을 나타내는 필드로 버전 6인 `0110`(2)가 들어간다.


* 트래픽 클래스 (8비트)  
우선도를 나타내는 필드, IPv4의 ToS와 같은 역활  


* 플로우 라벨 (20비트)  
플로우 라벨은 통신 흐름을 식별하는 필드이다.  


* 페이로드 길이 (16비트)  
페이로드의 길이가 담겨 있는 필드 


* 넥스트 헤더 (8비트) 
넥스트 헤더는 IPv6 헤더 바로 뒤에 이어지는 헤더를 나타내는 필드이다. 확장 헤더가 있다면 확장 헤더를 나타내는 값이 들어간다. 
만약 확장 헤더가 없다면 IPv4의 프로토콜 번호와 같은 역활을 한다.


* 홉 리미트 (8비트) 
IPv4의 TTL과 같은 역활


* 송/수신지 IPv6 주소 (각각 128비트)
IPv6 네트워크에 연결하는 단말을 나타내는 식별 ID이다.


| 비교 항목          | IPv4 주소         | IPv6 주소                                 |
|----------------|-----------------|-----------------------------------------|
| 길이             | 32비트            | 128비트                                   |
| 할당 가능한 IP 주소 수 | 약 43억(2^32)     | 약 320간(2^128)                           |
| 구분 문자          | 점(.)            | 콜론(:)                                   |
| 구분 간격          | 8비트(1바이트)       | 16비트(2바이트)                              |
| 표기법            | 10진수            | 16진수                                    |
| 표기 예           | 192.168.100.254 | 2001:0db8:1235:5678:90ab:cdef:1134:5678 |


<br>

IPv6의 주소가 너무 길다보니 표기시에 생략 규칙이 몇가지 있다.

* 각 필드 맨 앞에 연속한 0은 생략
* 여러 필드에 걸쳐 0이 이어진다면 ::으로 생략
* * 생략은 1번만 가능
* * 하나의 필드만 모두 0일때는 생략 불가
* * 가능한 짧게 만들기
* * 생략할 수 있는 필드가 여러 위치에 있다면 가장 첫 위치에서 생략

<!--애니 캐스트 정리, 라우팅 정리-->


## 4계층 - 전송 계층 (Transport Layer)

> * 프로토콜 : TCP, UDP  
> * 데이터 단위 : 세그먼트 (segment)

전송 계층에서는 `포트 번호`라는 숫자를 사용하여 패킷을 전달하는 애플리케이션을 식별한다. 그리고 애플리케이션의 요건에 따라
패킷 송수신량을 제어하거나 전송 도중에 손실된 패킷을 재전송한다.  
프로토콜로는 UDP와 TCP가 있고 각각 장단점을 가지고 있다.

### UDP 

**UDP**(User Datagram Protocol)은 비신뢰성 통신을 제공하는 대신 빠른 속도를 가지고 있다.  
때문에 음성 통신(VolP, Voice over IP), DHCP 등 즉시성을 요하는 애플리케이션에서 사용한다. 
빠른 통신을 위해 패킷의 헤더 필드는 4개, 헤더의 길이는 8바이트(64비트)로 매우 작다.  
데이터를 계속 보내기만 하고 받았는지의 잘 받았는지에 대한 여부는 묻지 않는다.  

* 송신지/수신지 포트 번호 `2바이트 (16비트)`  
포트 번호는 애플리케이션 식별에 사용되는 값이다. 


* UDP 데이터그램 길이 `2바이트 (16비트)`  
UDP 데이터그램의 길이는 UDP 헤더(8바이트)와 UDP 페이로드(애플리케이션 데이터)를 합친 데이터 그램 전체 길이를 나타내는 필드이다.


* 체크섬 `2바이트 (16비트)`  
체크섬은 UDP 데이터그램의 손상 여부 정합성 체크에 사용되는 필드이다. UDP 검증은 IP 헤더의 체크섬 처럼 1의 보수 연산을 사용한다.


### TCP 
**TCP**(Transmission Control Protocol)는 UDP와는 달리 신뢰성을 기반한 통신을 제공한다. 그래서 메일이나 파일 전송, 
웹브라우저 등 데이터 전송시에 신뢰성을 요구하는 애플리케이션에서 사용한다.  
송신 측 단말과 수신 측 단말이 2개의 논리적인 파이프를 전이중으로 사용해 보내는 신호와 받았다는 신호를 서로 주고 받는 방식을 사용한다.  
신뢰성을 제공하기 위해 TCP의 헤더는 조금 복잡하다. 헤더의 길이는 IP 헤더와 마찬가지로 최저 20바이트(160비트)다.

* 송신지/수신지 포트 번호 `2바이트(16비트)`  
UDP의 포트 번호와 마찬가지로 애플리케이션의 식별에 사용되는 숫자이다.  


* 시퀀스 번호 `4바이트(32비트)`  
시퀀스 번호는 TCP 세그먼트를 올바른 순서로 정렬하기 위해 사용되는 필드이다. 송신 측 단말은 애플리케이션에서 받은 데이터의 각 바이트에 
대해 **초기 시퀀스 번호**(ISN, Initial Sequence Number)에서 연번을 부여한다.

* 확인 응답 번호 `4바이트(32비트)`  
확인 응답 번호 (ACK: Acknowledge)는 다음 전송할 데이터의 위치를 알려준다.  


* 데이터 오프셋 `(4비트)`  
데이터 오프셋(data offset)은 TC 헤더의 길이를 나타내는 필드이다.


* 컨트롤 비트 `1바이트(8비트)`  
컨트롤 비트는 커넥션의 상태를 나타내는 필드이다.  

| 비트     | 플래그 이름 | 설명                               | 개요                                   |
|--------|--------|----------------------------------|--------------------------------------|
| 1번째 비트 | CWR    | Congestion Window Reduced        | ECN-Echo에 따라, 혼잡 윈도우가 줄어든 것을 알리는 플래그 |
| 2번째 비트 | ECE    | ECN-Echo                         | 혼잡이 발생한 것을 통신 상대에게 알리는 플래그           |
| 3번째 비트 | URG    | Urgent Pointer field significant | 긴급을 나타내는 플래그                         |
| 4번째 비트 | ACK    | Acknowledgment field significant | 확인 응답을 나타내는 플래그                      |
| 5번째 비트 | PSH    | Push Function                    | 빠르게 애플리케이션에 데이터를 전달하는 플래그            |
| 6번째 비트 | RST    | Reset the connection             | 커넥션을 강제로 끊는 플래그                      |
| 7번째 비트 | SYN    | Synchronize sequence numbers     | 커넥션을 여는 플래그                          |
| 8번째 비트 | FIN    | No more data from sender         | 커넥션을 닫는 플래그                          |


* 윈도우 크기 `2바이트(16비트)`  
확인 응답을 기다리지 않고 받을 수 있는 데이터 크기를 알린다.


* 체크섬 `2바이트(16비트)`  
TCP 체크섬 검증도 1의 보수 연산을 사용한다.


* 긴급 포인터 `2바이트(16비트)`  
긴급 포인터(urgent pointer)는 컨트롤 비트의 URG 플래그가 '1'로 설정됐을때 유효한 필드이다. 긴급 데이터가 있을 때 긴급 데이터를 나타내는 가장 마지막 바이트의 
시퀀스 번호가 설정된다. 


* 옵션 `4바이트(32비트)` 
옵션은 TCP에 관련된 확장 기능을 알리기 위해 사용한다.   

<br>
<br>


### 3 way handshake & 4 way handshake

TCP 통신에서 접속 시작은 `3 way handshake` 접속 종료는 `4 way handshake`를 사용한다.  

**3 way handshake**
> 1. 3웨이 핸드셰이크 이전에는 클라이언트는 **CLOSED** 서버는 **LISTEN** 상태이다.
> 2. 클라이언트 측에서 연결 플래그인 SYN 플래그를 1, 시퀀스 번호에는 랜덤한 값을 설정하여 SYN 패킷을 송신한다.  `SYN-SENT`
> 3. SYN 패킷을 받은 서버는 SYN 플래그 1과 ACK 플래그를 1로 설정하고, 확인 응답 번호에는 시퀀스 값 번호에 1을 더하여 SYN/ACK 플래그를 반환한다. `SYN-RESEIVED`
> 4. SYN/ACK 패킷을 받은 클라이언트는 이제 서버가 준 SYN/ACK 신호를 받았다는 의미에서 ACK 플래그를 1로 설정하고 ACK 패킷을 송신한다. `ESTABLISHED`
> 5. ACK 패킷을 받은 서버는 이제 데이터를 송수신할 수 있는 상태가 된다. `ESTABLISHED`
> > SYN, SYN/ACK, ACK

<br>
<br>


**4 way handshake**
> 1. 클라이언트는 서버와 통신을 종료하기 위해 FIN 플래그를 1로 설정하고 FIN 서버로 송신한다. `FIN-WAIT1`
> 2. FIN 패킷을 받은 서버는 ACK 패킷을 송신하고 애플리케이션의 클로즈 요청를 기다린다. `CLOSE-WAIT`
> 3. ACK 패킷을 받은 클라이언트는 서버의 FIN 패킷을 기다린다.`FIN-WAIT2`
> 4. 애플리케이션의 클로즈 요청이 왔다면 클라이언트한테 FIN 패킷을 전송한다. `LAST-ACK`
> 5. 서버한테 FIN 패킷을 받으면 그에 대한 ACK 패킷을 전송하고 **TIME_WAIT** 상태가 된다. `TIME-WAIT`
> 6. ACK 패킷을 받은 서버는 **CLOSED** 상태로 이동하고, 커넥션을 삭제한다. `CLOSED`
> 7. **TIME_WAIT** 가 끝나면 클라이언트도 **CLOSED** 상태로 이동하고, 커넥션을 삭제한다. `CLOSED`
> > FIN, ACK, FIN, ACK

<br>
<br>

### 흐름 제어, 혼잡 제어, 재전송 제어

* **흐름 제어**  
흐름 제어는 송신측 단말이 수행하는 패킷의 흐름양 조절이다. 이 기능은 TCP 헤더의 윈도우 크기를 바탕으로 작동한다. 송신측은 윈도우 크기에 담긴 
수만큼 수신측의 ACK 신호를 기다리지 않고 연달아 보낸다. 이렇게 함으로써 수신측 단말이 놓치는 데이터가 없도록 하면서 
송신측은 가능한 많은 데이터를 송신한다. 이 동작을 `슬라이딩 윈도우`라고 한다.


* **혼잡 제어**  
혼잡 제어는 수신측 단말이 수행하는 패킷의 흐름양 조절이다. 갑자기 많은 패킷이 전송되다 보면 네트워크가 혼잡해지는데 이를 해결하기 위해 혼잡 제어 
알고리즘을 이용해 패킷 송신수를 제어한다. 혼잡 제어 알고리즘 종류로는 패킷 로스(유실)가 발생함으로 혼잡을 판단하는 `로그 기반(loss base)`,
지연이 발생함으로 혼잡을 판단하는 `지연 기반(latency base)`, 패킷 유실과 지연 양쪽을 종합적으로 고려하여 혼잡을 판단하는 `하이브리드 기반(hybrid base)`이 있다.  


* **재전송 제어** 
재전송 제어는 패킷 유실이 발생했을 때 수행하는 패킷 재전송 기능이다. 재전송 제어는 수신 측 단말이 계기가 되어 `중복 ACK`가 발생 했을 때 그리고 송신 측 단말이 계기가 되어 `재전송 타임아웃`시에 발동한다.



| 항목             | UDP        | TCP       |
|----------------|------------|-----------|
| IP 헤더의 프로토콜 번호 | 17         | 6         |
| 타입             | 커넥션리스 타입   | 커넥션 타입    | 
| 신뢰성            | 낮음         | 높음        |
| 즉시성(실시간성)      | 빠름         | 느림        |
| 패킷 교환 방식       | 데이터그램 패킷교환 | 가상화선 패킷교환 |
| 순서 보장          | X          | O         |


패킷을 전달할 때 TCP는 가상 회선을 만들어서 그 경로로만 전송하기 때문에 순서를 보장하지만,
UDP는 패킷마다 현재 가장 빨리 갈 수 있는 경로를 선택하여 전송하기 때문에 순서가 보장되지 않는다.  


## 5계층 - 세션 계층 (Session Layer)

> 프로토콜: ADSP, TLS, SSL  
> 데이터 단위: 메세지 (Message)

세션계층에서는 프로세스 간에 세션을 생성, 유지, 종료하는데 필요한 기능을 제공한다.  

## 6계층 - 표현 계층 (Presentation Layer)  

> 프로토콜: JPEG, MPEG  
> 데이터 단위: 메세지 (Message)  

표현 계층에서는 크게 암호화와 압축 그리고 코드 변환 기능을 제공한다.  


## 7계층 - 응용 계층 (Application Layer)

> 프로토코: HTTP, SSL, DNS, SMTP  
> 데이터 단위: 메세지 (Message)  

응용 계층은 사용자와 연결한다. 제공하는 기능으로는 사용자 인터페이스, 전자 우편 그리고 데이터베이스 관리 등이 있다.  

### HTTP  
**HTTP**(Hypertext Transfer Protocol)은 초기에는 텍스트 파일을 다운로드하기 위한 목적으로 간소한 프로토콜이었지만 점점 발전해가면서
파일 송수신, 실시간 메시지 교환, 동영상 송출 등등 많은 용도에서 사용한다.  

#### HTTP 버전

>HTTP/0.9 ___(1991)___
* 텍스트 파일 다운로드
* 헤더나 바디 등 메시지 포맷 규정도 존재하지 않음
* 현재는 사용되지 않음  

단순히 HTML로 작성된 텍스트 파일을 서버에서 다운받는 기능밖에 하지 못하였다.  

<br>


> HTTP/1.0 ___(1996)___
* RFC1945로 표준화
* 메시지 포맷 책정
* 다양한 파일 전송 가능
* 다운로드 업로드 가능  

HTTP/1.0 버전 부터 다운로드 이외의 업로드나 삭제도 가능해졌다. `요청(request)`이나 `응답(response)`의
기본적인 사용도 이 시점에서부터 확립되어 현재까지 이어졌다.  
HTTP/0.9와 HTTP/1.0은 리퀘스트마다 TCP 커넥션을 만들고 부수는 작업을 반복하는 방식을 사용했기에 많은 클라이언트가 서버에 막대한 부하가 걸렸다.  

<br>
<br>


>HTTP/1.1 ___(1997)___
* RFC2068이나 RFC2616, RFC7230 ~ 7235로 표준화
* HTTP/1.0 업그레이드 버전
* 파이프라인 기능 추가
* 킵얼라이브 기능 추가  

**킵업라이브**  
킵업라이브는 한 번 만들어진 TCP 커넥션을 재사용 하는 기능이다. 앞서 말한 HTTP/1.0 버전은 리퀘스트마다 TCP 오픈과, TCP 클로즈를 매번 수행했다면, 
킵업라이브가 활성화되면, TCP 커넥션을 만들어 두고 그 위에 여러 HTTP 요청을 송신한다. TCP에 관한 처리가 사라지게 되어 효율적이다.  

**파이프라인**  
파이프라인은 요청에 대한 응답을 기다리지 않고, 바로 다음 요청을 송신하는 기능이다. 이전에는 요청을 하고 응답이 오기 전까지 기다려야 했다면, 
파이프라인이 활성화되고 나서는 여러 리퀘스트를 계속 송신할 수 있기 때문에 사용자가 많은 콘텐츠로 구성된 웹사이트를 볼 때, 시간이 단축됐다.  
하지만 파이프라인의 성능은 기대에 미치지 못하였다. 이유는 HTTP/1.1 버전에서는 같은 TCP 커넥션 안에서 요청과 응답의 교환을 병렬 처리할 수 없는 
사양이었기 때문에 서버는 요청을 받은 순서대로 응답을 반환하여야 했다. 때문에 먼저 송신된 하나의 리퀘스트가 지연이 된다면 이어진 리퀘스트에 대한 응답도
반환되지 않는다. 이 현상을 `HoL 블로킹(Head of Lock Blocking)`이라고 부른다. HoL 블로킹 때문에 크롬은 물론 파이어폭스에서도 파이프라인은 비활성화 되어있다.  

<br>
<br>


>HTTP/2 ___(2015)___
* RFC7540으로 표준화(SPDY)기반
* 바이너리 형식으로 통신
* 멀티플렉싱/헤더 압축/서버 푸시 추가
* 거대 웹사이트에서의 채용 확대

**멀티플렉싱**  
HoL 블로킹 이슈 때문에 잘 사용되지 않는 파이프라인을 대신하고자 나온 것이 멀티플렉싱이다.  
멀티플렉싱은 1개의 TCP커넥션 안에 스트림이라는 가상 채널을 만들고, 스트림별로 요청과 응답을 교환하게 함으로써 
HoL 블로킹 문제를 해소한다.  

**HPACK**  
HPACK은 메시지 헤더를 압축하는 기능이다. 자주 사용하는 HTTP 헤더 이름이나 헤더를 정적으로 결정한 숫자로 치환하거나
한 번 송신한 HTTP 헤더를 동적으로 할당한 숫자로 치환하는 등 헤더의 전송량을 줄이는 것이 목표이다.  


**서버 푸시**  
HTTP/2에서는 하나의 요청에 여러 응답을 반환하는 푸시 타입 기능을 추가하였는데 이것이 서버 푸시이다. HTTP/2 서버는 클라이언트가 최초로 요청한 콘텐츠를 
해석하고, 다음에 올 요청에 대한 응답을 요청하기 전에 미리 송신한다. 브라우저는 미리 온 응답을 캐시에 저장하고, 요청이 오면 캐시 영역에서 호출한다.  
예를 들어 index.html이 script.js와 style.css를 로딩하는 HTML일때, *GET index.html* 요청시 index.html을 반환하고 또 script.js와 style.css도 동시에
반환하는 것이다.

<br>

>HTTP/3 ___(2020)___
* 현재 규격 책정 중(QUIC) 기반
* HTTP/2 업그레이드 버전
* UDP/TLS 1.3을 사용해 성능 향상

**UDP 사용**
HTTP/3의 가장 큰 차이점이라고 할 수 있는 것은 TCP가 아닌 UDP를 사용한다는 것이다. 이로써 3웨이 핸드셰이크에 걸리는 시간을 줄이고
더 많은 HTTP 데이터를 보낼 수 있게 되었다.


[//]: # (#### HTTP 상태 코드)

[//]: # (| 클래스 | 상태 코드 | 리즌 프레이즈  | 설명                      |)

[//]: # (|-----|-------|----------|-------------------------|)

[//]: # (| 1xx | 100   | Continue | 클라이언트는 리퀘스트를 계속 할 수 있다. |)

[//]: # ()
[//]: # ()
### SSL/TLS 

**SSL**(Secure Socket Layer)/**TLS**(Transport Layer Security)는 암호화 프로토콜이다.  

HTTP를 SSL/TLS로 암호화 한것이 바로 **HTTPS**(HyperText Transfer Protocol Secure)이다.  
TLS는 SSL의 버전을 업데이트 한것이다. SSL은 **암호화, 해시화, 디지털 인증서**라는 3가지 기술을 조합해 사용함으로써 보안을 지킨다.  


* **암호화를 통한 도청 방지**
* - 공통키 암호화 방식
* - 공개키 암호화 방식
* **해시화를 통한 변조 방지**
* **디지털 인증서를 통한 신분 위조 방지**

HTTPS 서버를 인터넷에 공개할 때는 서버인증서를 준비, 인증 기관으로의 신청 등을 사전에 준비해야한다. HTTPS 서버를 공개하기까지의 
흐름은 다음과 같다.
1. 비밀키 생성
2. CSR 작성
3. 신원 조사 & 서명
4. 설치

#### **비밀키 생성**  
HTTPS 서버에서 비밀키를 만든다.  
ex) 비밀키 파일  
```text
-----BEGIN RSA PRIVATE KEY-----

miIZTYdyz

-----END RSA PRIVATE KEY-----
```

#### **CSR 작성**
위에서 만든 비밀키를 기반으로 **CSR**(Certificate Signing Request)을 만들어 인증 기관에 보낸다. CSR이란 서버 인증서를 
얻기 위해 인증 기관에 제출하는 신청서이다.  
```text
-----BEGIN CERTIFICATE REQUEST-----

-----END CERTIFICATE REQUEST-----
```

####  **신원 조사 & 서명**  
신청자의 신원을조사한다. 여신(신용) 데이터를 조회하거나 제3자 기관의 데이터베이스에 기재된 전화번호로 전화하는 등 인증 기관 안에서 정해진
여러 프로세스에 기반하여 수행한다. 
```text
-----BEGIN CERTIFICATE-----

-----END CERTIFICATE-----
```

#### **설치**  
인증 기관에서 받은 서버 인증서를 서버에 설치한다. 

<br>
<br>


### SSL 핸드 셰이크
SSL 핸드 셰이크는 웹브라우저와 HTTPS 서버가 서로 어떻게 메시지를 암호화하여 통신할 지 사전에 준비하는 과정이다.  
![SSL 핸드 셰이크](ssl-tls-handshake.png)  


서버와 통신하는 방법은 크게 4단계로 구성되어 있다.  
1. 대응 방식 제시
2. 통신 상대 증명
3. 공통키 재료 교환
4. 최종 혹인


**대응하는 암호화 방식과 해시 함수 제시**  
웹브라우저는 서버에게 사용할 수 있는 암호화 방식이나 해시화 방식의 조합 목록이 담긴 `Client Hello` 메시지를 송신한다. 이 조합을 **암호 스위트**(cipher suite)라고
부른다. 또한 추가로 SSL과 HTTP의 버전, 공통키 작성에 필요한 **client random** 등도 같이 보단다.


**통신 상대 증명**  
**Server Hello, Certificate, Server Hello Done**의 3가지 프로세스로 구성되어 있다.  

1. Server Hello  
서버는 Client Hello에 받은 암호 스위트와 자신이 가지고 있는 암호 스위트를 비교한 것 중에 가장 우선도가 높은 암호 스위트를 선택한다.
또한 클라이언트와 맞춰야하는 **server random** 등 정보도 **Server Hello**로 반환한다.
2. Certificate  
Certificate로 서버 인증서를 보내서, 자신이 제3자 기관으로부터 인증받았다는 것을 증명한다.
3. Server Hello Done  
Server Hello Done으로 정보 전송 완료를 알린다.  웹브라우저는 받은 서버 인증서를 검증(루트 인증서로 복호화 -> 해시값 비교)하고, 올바른 서버인지 확인한다. 

**공통키 교환**  
웹브라우저는 통신 상대가 실제 서버인 것을 확인하면 **프리 마스터 시크릿**(pre-master secret)이라는 공통키의 재료를 만들어
서버로 보낸다. 웹브라우저와 HTTPS 서버는 이 프리 마스터 시크릿과 Client Hello로 얻은 client random, Server Hello에서 얻은 server random을 
섞어 **마스터 시크릿**(master secret)을 만든다. 서버와 클라이언트는 client random과 server random을 교환했기에 서로 프리 마스터 시크릿만 보내도 마스터 시크릿을
만들 수 있다.
이 마스터 시크릿을 이용해 애플리케이션의 데이터의 암호화에 사용하는 공통키 **세션키**와 해시화에 사용하는 **MAC키**를 만든다.  
웹브라우저는 `Client Key Exchange`로 프리 마스터 시크릿을 공개키로 암호화해서 보낸다. 이를 받은 서버는 비밀키로 복호화해서 프리 마스터 시크릿을 추출하고 
client random과 server random을 뒤섞어 마스터 시크릿을 만든다. 그리고 마스터 시크릿에서 세션키와 MAC키를 생성함으로써 공통키 생성이 완료된다.  


**최종 확인 작업**
서로 `Change Cipher Spec`과 `Finished`를 교환하고, 이제까지 결정한 결정한 사항들을 확인하고, SSL 핸드셰이크를 종료한다. 이제 SSL 세션이 만들어지고
애플리케이션 데이터 암호화 통신을 시작한다. 

### DNS


---

### reference
[그림으로 공부하는 TCP/IP 구조](http://www.yes24.com/Product/Goods/104210768)  
[[브라우저에 URL 입력 후 일어나는 일들] 5_TLS/SSL Handshake](https://wangin9.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90-URL-%EC%9E%85%EB%A0%A5-%ED%9B%84-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%9D%BC%EB%93%A4-5TLSSSL-Handshake)